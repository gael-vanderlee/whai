---
alwaysApply: true
---
# **"terma" Implementation Guide: Constraints & Key Issues**

This file outlines the critical design decisions and constraints that must be handled correctly.

## **1\. State Management (cd, export)**

* **Problem:** How can the LLM run cd /tmp and then run ls *in that new directory*?  
* **Solution:** The persistent subprocess.Popen architecture (defined in terma\_implementation.md) solves this.  
* **Constraint:** This state (cd, export) exists *only* within the terma session shell. It **cannot** and **will not** affect the user's parent terminal.  
* **Action:** The hardcoded "base prompt" given to the LLM *must* be explicit about this: "You can use cd and export. Your changes will be remembered *for this conversation*, but they will not change the user's main terminal."

## **2\. sudo Password Handling**

* **Problem:** How does terma handle a command that runs sudo and needs a password?  
* **Solution:** terma does nothing.  
* **Action:** The Popen process (or a subprocess.run call specifically for sudo) will have its stdin/stdout/stderr connected to the user's terminal. The sudo program will naturally and automatically take over the TTY to ask for a password. The terma process simply waits for the subprocess to complete. Do not try to intercept or manage the password.

## **3\. End-of-Command Detection**

* **Problem:** When terma writes grep 'error' syslog\\n to the Popen shell's stdin, how does it know when the grep command has finished running and all its output has been printed?  
* **Solution:** Use a unique marker.  
* **Action:** After writing the command, the interaction.py module *must* immediately write a second command to stdin: echo "TERMA\_CMD\_DONE\_MARKER"\\n (or a similar unique string).  
* terma must then read stdout and stderr line-by-line. All lines are buffered as the command's output *until* the line "TERMA\_CMD\_DONE\_MARKER" is read. This signals the end of the output.

## **4\. tmux vs. Fallback Context**

* **Problem:** The user wants "post-mortem" (e.g., terma why did this fail?).  
* **Solution:** This is only possible with deep context (commands \+ their output).  
* **Action:** The context.py module *must* check for the TMUX environment variable.  
  * **If TMUX exists:** Run tmux capture-pane \-p to get the full scrollback buffer. This is the "happy path."  
  * **If TMUX does not exist:** Fall back to reading \~/.zsh\_history (or equivalent).  
  * **Constraint:** The LLM must be informed if it's operating in "shallow context" mode, as it won't be able to see *why* a command failed (it can only see the command itself). This can be part of the system prompt.

## **5\. Safety: The Approval Loop**

* **Problem:** The LLM cannot be allowed to run destructive commands without permission.  
* **Solution:** The \[a\]pprove/\[r\]eject loop.  
* **Action:** This is non-negotiable. No command is *ever* written to the Popen shell's stdin until the user has explicitly typed a and pressed Enter. This logic is the core of interaction.py.